# coding: utf-8


# This file was *autogenerated* from the file ipynb/cubic_hecke_algebra_tutorial.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_25 = Integer(25); _sage_const_4 = Integer(4); _sage_const_6 = Integer(6); _sage_const_648 = Integer(648)#!/usr/bin/env python

# # Using  the SageMath CubicHeckeAlgebra class
# 
# ## Introduction
# 
# $\newcommand{\Q}{{\mathbb Q}\,}$
# 
# ### Usage
# 
# This tutorial comes as an Jupyter notebook (`ipynb`) which may have been exported to a `pdf`, `html` or a `sage` file. In case you are reading it in a Jupyter client you may experiment with the examples when running the corresponding cells. You are welcome to do that. But if you are doing it on a pinned [Gitpod](https://gitpod.io/) worspace (for example [this one](zu)) please edit a copy of the original file. If you don't have a SageMath distribution of a release at least 9.7 then (besides Gitpod workspaces) it is possible to use [Docker](https://www.docker.com/) to work through the examples. 
# 
# ### About
# 
# This tutorial is about a [class](https://doc.sagemath.org/html/en/reference/algebras/sage/algebras/hecke_algebras/cubic_hecke_algebra.html) of the [SageMath](http://www.sagemath.org/) library which is available since [release 9.7](https://wiki.sagemath.org/ReleaseTours/sage-9.7). It allows to do calculations in [cubic Hecke algebras](https://arxiv.org/abs/1110.6621), which are certain [epimorhic images](https://en.wikipedia.org/wiki/Epimorphism) of [group algebras](https://en.wikipedia.org/wiki/Group_ring) of [Artin braid groups](https://en.wikipedia.org/wiki/Braid_group).
# 
# More explicitly, we consider the factors such that the images $s_i$ of the braid generators satisfy a cubic equation:
# 
# $$ s_i^3 = u s_i^2 - v s_i + w $$
# 
# Here $u, v, w$ are elements in an arbitrary [integral domain](https://en.wikipedia.org/wiki/Integral_domain). By the analogue to the [Iwahori Hecke algebras](https://doc.sagemath.org/html/en/reference/algebras/sage/algebras/iwahori_hecke_algebra.html), in which the braid generators satisfy a quadratic relation these algebras have been called *cubic Hecke algebras*.
# 
# The relations inherited from the braid group are:
# 
# $$s_i s_{i+1} s_i = s_{i+1} s_i s_{i+1} \text{ for } 1 \leq i < n - 1
#     \mbox{ and } s_i s_j = s_j s_i \text{ for } 1 \leq i < j - 1 < n - 1.$$
# 
# 
# The algebra epimorphism from the [braid group algebra](https://doc.sagemath.org/html/en/reference/algebras/sage/algebras/hecke_algebras/cubic_hecke_algebra.html#sage.algebras.hecke_algebras.cubic_hecke_algebra.CubicHeckeAlgebra.braid_group_algebra) over the same base ring is realized inside the [element constructor](https://doc.sagemath.org/html/en/reference/structure/sage/structure/parent.html?highlight=element%20constructor#sage.structure.parent.Parent.__call__) of the present class which is executed when in instance of the class is applied to apropriate data. For example in the case of the 3 strand cubic Hecke algebra we obtain the braid group by the method [braid_group](https://doc.sagemath.org/html/en/reference/algebras/sage/algebras/hecke_algebras/cubic_hecke_algebra.html#sage.algebras.hecke_algebras.cubic_hecke_algebra.CubicHeckeAlgebra.braid_group) and define a braid with its help:

# In[1]:


CHA3 = algebras.CubicHecke(_sage_const_3 )
BG3 = CHA3.braid_group()
braid = BG3((_sage_const_1 ,_sage_const_2 ,-_sage_const_1 ,_sage_const_2 ,_sage_const_2 ,-_sage_const_1 )); braid


# In[2]:


braid_image = CHA3(braid); braid_image


# If the ring elements $u, v, w$ (which will be called the [cubic equation parameters](https://doc.sagemath.org/html/en/reference/algebras/sage/algebras/hecke_algebras/cubic_hecke_algebra.html#sage.algebras.hecke_algebras.cubic_hecke_algebra.CubicHeckeAlgebra.cubic_equation_parameters) in the sequel) are taken to be $u = v = 0, w = 1$ the cubic Hecke algebra specializes to the group algebra of the [cubic braid group](https://doc.sagemath.org/html/en/reference/groups/sage/groups/cubic_braid.html?highlight=cubic%20braid%20group#cubic-braid-groups), which is the factor group of the Artin braid
# group under setting the generators order to be three. A class to work with these groups
# is attached to this class and can be obtained by the [cubic_braid_group](https://doc.sagemath.org/html/en/reference/algebras/sage/algebras/hecke_algebras/cubic_hecke_algebra.html#sage.algebras.hecke_algebras.cubic_hecke_algebra.CubicHeckeAlgebra.cubic_braid_group)-method. 
# 
# 
# It is well known, that these algebras are free of finite rank as long as the number of braid generators is less than six and infinite dimensional elsewise. In the former (non trivial) cases they are also known as [cyclotomic Hecke algebras](https://www.researchgate.net/publication/1768251_On_the_cyclotomic_Hecke_algebras_of_complex_reflection_groups) corresponding to the [complex reflection groups](https://doc.sagemath.org/html/en/reference/categories/sage/categories/complex_reflection_groups.html?highlight=complex%20reflection%20groups#complex-reflection-groups)
# having Shepard-Todd number $4, 25$ and $32$ (see the table at [Wikipedia](https://en.wikipedia.org/wiki/Complex_reflection_group)).
# 
# Since the [BrouÃ©, Malle and Rouquiere](https://arxiv.org/abs/1606.08456) conjecture has been proved in all these cases (for references see [Mar2012] below) there exists a finite free basis of the cubic Hecke algebra which is in bijection to the cubic braid group and compatible with the specialization to the cubic braid group algebra as explained above.
# 
# For the algebras corresponding to braid groups of less than five strands such a basis has been calculated by Ivan Marin. This one is used here via a [Python wrapper](https://github.com/soehms/database_cubic_hecke#readme). In the case of 5 strands such a basis is not available, right now. Instead the elements of the cubic braid group class themselves are used as basis elements. This is also the case when the cubic braid group is infinite, even though it is not known if these elements span all of the cubic Hecke algebra.
# 
# Accordingly, be aware that the realization of the coercion map from the group algebra of the cubic braid groups is known to be an isomorphism of free modules only in the cases of less than five strands. 
# 
# 
# REFERENCES:
# 
# - [CM2012](https://arxiv.org/abs/1010.1465) M. Cabanes, I. Marin, On ternary quotients of cubic Hecke algebras, Comm. Math. Phys. August 2012, Volume 314, Issue 1, pp 57-92, [doi](https://doi.org/10.1007/s00220-012-1519-7).
# - [Mar2012]( https://arxiv.org/abs/1110.6621) Ivan Marin: The cubic Hecke algebra on at most 5 strands. Journal of Pure and Applied Algebra 216 (2012) 2754-2782, [doi](https://doi.org/10.1016/j.jpaa.2012.04.013).
# - [Mar2018](http://www.lamfa.u-picardie.fr/marin/arts/GQ.pdf) Ivan Marin: Preprint A  MAXIMAL  CUBIC  QUOTIENT  OF  THE  BRAID  ALGEBRA.

# ## First steps
# 
# In the global namespace of Sage the cubic Hecke algebra is present as `algebras.CubicHecke`. Online help can be requested with a question mark right behind the last character: `algebras.CubicHecke?`. This also works for all instances of classes and methods that you may define in the sequel, for examples `CHA3?` after running the next cell gives the same information, but `CHA3.cubic_hecke_subalgebra?` displays the online-help for that specific method.
# 
# To define the cubic Hecke algebra on 3 strands,type:

# In[3]:


CHA3 = algebras.CubicHecke(_sage_const_3 ); CHA3


# In[4]:


CHA3.inject_variables(); c0*c1


# If you like to use your own names it is possiblbe to include a generator declaration inside the algebra declaration:

# In[5]:


CHA3abc = algebras.CubicHecke(_sage_const_3 , cubic_equation_parameters='a, b, c', cubic_equation_roots='x, y, z', names=('c1', 'c2',)); (c1, c2,) = CHA3abc._first_ngens(2); CHA3abc


# The underlying cubic equation of the algebra can be obtained by:

# In[6]:


CHA3.cubic_equation()


# In[7]:


CHA3abc.cubic_equation()


# So far, the only difference between these both definitions of a cubic Hecke algebra consists in the names of the parameters. The argument `cubic_equation_parameters` can also be used to define the algebra over a specialized ring:

# In[8]:


BRQ = FractionField(ZZ['p,q,r'], names=('p', 'q', 'r',)); (p, q, r,) = BRQ._first_ngens(3)
CHA3pqr = algebras.CubicHecke(_sage_const_3 , cubic_equation_parameters=(p, q, r)); CHA3pqr


# The roots are constructed in a maximal extension ring if they don't belong to the domain of the `cubic_equation_parameters`:

# In[9]:


roots = CHA3pqr.cubic_equation_roots(); print(roots)
roots[_sage_const_0 ].parent()


# In[10]:


Z3 = CyclotomicField(_sage_const_3 )
e = Z3.gen()
CHA3z3 = algebras.CubicHecke(_sage_const_3 , cubic_equation_parameters=(e, e**_sage_const_2 , _sage_const_1 )); CHA3z3


# In[11]:


roots = CHA3z3.cubic_equation_roots(); print(roots)
roots[_sage_const_0 ].parent()


# In[12]:


CHA3int = algebras.CubicHecke(_sage_const_3 , cubic_equation_parameters=(_sage_const_5 , _sage_const_7 , _sage_const_11 )); CHA3int


# In[13]:


roots = CHA3int.cubic_equation_roots(); print(roots)
roots[_sage_const_0 ].parent()


# You can predefine the roots of the cubic equation, as well:

# In[14]:


GF25 = GF(_sage_const_25 ,'t')
g2 = GF25(_sage_const_1 )
g3 = GF25.gen()
g4 = GF25(_sage_const_3 )
CHA3gf25 = algebras.CubicHecke(_sage_const_3 , cubic_equation_roots=(g2, g3, g4)); CHA3gf25


# Examples of Elements:

# In[15]:


print('Element of CHA3 %s' %(CHA3.an_element()))
print('Element of CHA3abc %s' %(CHA3abc.an_element()))
print('Element of CHA3pqr %s' %(CHA3pqr.an_element()))
print('Element of CHA3z3 %s' %(CHA3z3.an_element()))
print('Element of CHA3int %s' %(CHA3int.an_element()))
print('Element of CHA3gf25 %s' %(CHA3gf25.an_element()))


# Multiplication is possible without any restriction in the cubic Hecke algebra up to four strands:

# In[16]:


ele3 = CHA3.an_element()
ele3*c0


# ## Matrix representations
# 
# To each element you can obtain matrix representations of different types. By default this is a block-matrix, whose blocks are the  split irreducible representation which are available at [Ivan Marin's hompage](http://www.lamfa.u-picardie.fr/marin/softs/H4/RepresentationsH25):

# In[19]:


CHA2 = CHA3.cubic_hecke_subalgebra()
ele2 = CHA2.an_element(); print(ele2)
m = ele2.matrix(); m


# Here the entries are taken from an extension of the base ring (indeterminates u, v, w) splitting the cubic equation with roots a, b, c. This ring is called the extension ring of `CHA3`:

# In[20]:


m.base_ring() == CHA2.extension_ring()


# The original version with entries being Laurent polynomials in $a, b, c$ can be obtained using the keyword option `original` or by changing the base ring to the *generic* extension ring:

# In[21]:


mo = ele2.matrix(original=True)
mo == m.change_ring(CHA2.extension_ring(generic=True))


# A single irreducible representation can be obtained by array index which can be an integer:

# In[22]:


m[_sage_const_1 ]


# In[23]:


mo[_sage_const_1 ]


# or an enum naming the representation:

# In[24]:


mo[CHA2.irred_repr.W2_100]


# Other representation types are the left and right regular representations, which are taken from Ivan Marin's home page, as well:

# In[25]:


ml = ele2.matrix(representation_type=CHA2.repr_type.RegularLeft); ml


# and (in case [GAP3](https://webusers.imj-prg.fr/~jean.michel/gap3/) is installed together with its package `CHEVIE`) the split irreducibles available from there. In case of the two strand algebra they coincide with Marin's version: 

# In[26]:


mg = ele2.matrix(representation_type=CHA2.repr_type.SplitIrredChevie)
m == m.parent()(mg)


# but not in general:

# In[27]:


CHA3 = algebras.CubicHecke(_sage_const_3 )
c1, c2 = CHA3.gens()
m1 = c1.matrix()
m1g = c1.matrix(representation_type=CHA3.repr_type.SplitIrredChevie)
m1.dict() == m1g.dict()


# Furthermore, you may obtain irreducible matrix representations for cubic Hecke algebras on 5 strands by using `SplitIrredChevie` which is not possible for the other types (see the examples in the last section).

# # An Application: Defining minimal quasi-idempotents 
# 
# Let's apply the `CubicHeckeAlgebra` to some investigation concerning the obstruction `b` of the `triple quadratic algebra` from section 2.6 of [Mar2018]. It generates the vanishing ideal inside the cubic Hecke algebra on three strands. We will construct scalar multiples of two minimal idempotents (called minimal quasi-idempotents) summing up to it. We start with definition of `b`:

# In[28]:


CHA3 = algebras.CubicHecke(_sage_const_3 )
c1, c2 = CHA3.gens()
BR = CHA3.base_ring()
u, v, w = BR.gens()
b = c1**_sage_const_2 *c2 - c2*c1**_sage_const_2  - c1*c2**_sage_const_2  + c2**_sage_const_2 *c1; b


# For convenience we will rather use a scalar multiple `b1` of the original `b` dividing by the invertibe constant coefficient `-w` of the cubic equation:

# In[29]:


b1  = ~w*b; b1


# The third power of `b1` is a scalar multiple of `b1` itself (in fact it operates as a projection onto a two dimensional submodule of the three dimensional irreducible module `W3_111` of `CHA3`):

# In[30]:


b2 = b1*b1
b3 = b2*b1
f =  BR(b3.coefficients()[_sage_const_0 ]/_sage_const_2 )
ER = CHA3.extension_ring()
ER(f) == CHA3.schur_element(CHA3.irred_repr.W3_111) # that means: f is the Schur element of the 3 dimensional irreducible 


# In[31]:


b3 == _sage_const_2 *f*b1


# First, lets split it into a sum of two minimal quasi-idempotents:

# In[32]:


by = b2 - b1*~c1*c2*b1 
yb = b2 - b1*c1*~c2*b1 
f*b1 == yb - by


# The choice of their names matches the following visualization (yellow-blue, blue-yellow) which is set upon the *Turaev-Kassel concept* of *tangles with coupon*. Here the coupon should be looked as pieces of ribbons which are colored opposite at corresponding backside spaces, such that they appear to be identical when turning horizontally to the backside (thus `yb` is the backside of itself but the mirror image of `by`).
# 
# <p><img src="pictures/skeinrel.png" title="Skein relation" /></p>
# 
# This visualization was driven by the hope that one day these coupon can be replaced by proper *tangle diagrams* leading to a useful *skein relation* for *cubic polynomial link invarinants* in analogy (resp. generalization) of the *cap-cup tangle* of the *Kauffman polynomial skein relation* where this tangle represents a minimal quasi-idempotent, as well. The only purpose of the coloring of the coupon is to reflect their symmetry properties verified below.
# 
# But first, let's verify that these elements are quasi-idempotents. To this aim let's introduce some auxillary base ring elements:
# 

# In[33]:


g1 = _sage_const_2 *v - u**_sage_const_2 
g2 = _sage_const_2 *u*w - v**_sage_const_2 
g3 = _sage_const_4 *w - u*v
f1 = f*g1/w
f2 = f*g2/w
f3 = f*g3/w

f == _sage_const_2 *g3/w - u*g1/w - v*g2/w**_sage_const_2 


# Now, we can varify:

# In[34]:


yb**_sage_const_2  == f3*yb


# In[35]:


by**_sage_const_2  == f3*by


# In[36]:


B = f3.parent().markov_trace_version()
h = B.specialize_homfly(); h


# ### Another interesting pair of minimal idempotents
# 
# This can easily be obtained from the first pair. Graphically they are defined as follows:
# 
# <p><img src="pictures/ybbydef1.png" title="ybby1" /></p>
# <p><img src="pictures/ybbydef2.png" title="ybby2" /></p>
# 
# We choose according notation reading the coloures from bottom to top and left to right:

# In[37]:


ybby =  ~c1*by   
ybby == ~c2*by


# In[38]:


ybby == yb*~c1


# In[39]:


ybby == yb*~c2


# In[40]:


ybby**_sage_const_2  == f1*ybby


# ### Similarily in the mirror case:
# 
# <p><img src="pictures/byybdef1.png" title="ybby1" /></p>
# <p><img src="pictures/byybdef2.png" title="ybby2" /></p>

# In[41]:


byyb =  by*c1   
byyb == by*c2


# In[42]:


byyb == c1*yb


# In[43]:


byyb == c2*yb


# In[44]:


byyb**_sage_const_2  == f2*byyb


# Graphically the quasi-idempotent property looks like this, for example:
# 
# <img src="pictures/ybby_qid.png" title="ybby-quasi-idempotent" />
# <img src="pictures/byyb_qid.png" title="byyb-quasi-idempotent" />
# 
# 
# ### Symmetry properties
# 
# Looking into the mirror:

# In[45]:


by.revert_mirror() == yb


# this is not true since the parents are different:

# In[46]:


by.revert_mirror().parent() == yb.parent()


# In[47]:


by.revert_mirror().parent()


# But the coefficient vectors agree:

# In[48]:


by.revert_mirror().to_vector() == yb.to_vector()


# In[49]:


byyb.revert_mirror().to_vector() == ybby.to_vector()


# Turning to the backside:

# In[50]:


by.revert_garside() == by


# In[51]:


yb.revert_garside() == yb


# In[52]:


byyb.revert_garside() == byyb


# In[53]:


ybby.revert_garside() == ybby


# Reverting the orientation:

# In[54]:


byyb.revert_orientation() == byyb


# In[55]:


ybby.revert_orientation() == ybby


# In[56]:


by.revert_orientation() == yb


# ### Consequent melting rules

# In[57]:


byyb * ybby == f3 * by


# that is: <img src="pictures/byyb_ybby.png" title="byyb_ybby_melt" />

# In[58]:


ybby * byyb == f3 *yb


# that is: <img src="pictures/ybby_byyb.png" title="ybby_byyb_melt" />
# 
# Furthermore:

# In[59]:


by * byyb == f3 *byyb


# In[60]:


byyb * yb == f3 *byyb


# In[61]:


yb * ybby == f3 *ybby


# In[62]:


ybby * by == f3 *ybby


# ### Compensation of halfturn and fullturn

# In[63]:


halfturn = c1*c2*c1
fullturn = halfturn**_sage_const_2 
yb * halfturn == -w * yb == halfturn * yb, yb * fullturn == w**_sage_const_2  * yb == fullturn * yb


# In[64]:


by * halfturn == -w * by == halfturn * by, by * fullturn == w**_sage_const_2  * by == fullturn * by


# In[65]:


ybby* halfturn == -w*ybby,  byyb* halfturn == -w*byyb


# ## Examples with more than 3 stands
# 
# To use the cubic Hecke algebra functionallity for larger cases you need to install an optional package into your Sage distribution. There are two ways to do this:
# 
# 1. Run `sage -i database_cubic_hecke` in a bash commandline shell.
# 2. Run `sage -pip install database_cubic_hecke` in a bash commandline shell.
# 
# The advantage of the first option is that you will get a version of the optional package which is compatible with the documentation of your current Sage version. The disadvantage is that it may fail on some systems and runs much longer as the second option.
# 
# The advatage of the second option is that it gives you the latest version and installation is very fast. On the other hand (since this version can be newer than the version of your Sage distribution) it is not guaranteed that all examples of the Sage documentation are still valid.
# 
# The examples of this section only work if this optional package has been installed.

# In[66]:


CHA4 = algebras.CubicHecke(_sage_const_4 )
ele4 = CHA4.an_element(); ele4


# To obtain a sorted list of the involved basis elements in the former expression type:

# In[67]:


sup = sorted(ele4.support()); sup


# Note, that these are not embedded in the `CHA4` a priori. As basis elements they belong to the cubib braid group:

# In[68]:


sup1 = sup[_sage_const_0 ]
sup1.parent()


# But they can be mapped into the algebra by applying `CHA4` to them:

# In[69]:


ele4 * CHA4(sup1)


# ### Infinite dimensional algebras
# 
# If the optional package is present you can even work with the infinite dimensional algebras, but just under certain restrictions.Be aware that this part of the functionality is in an experimental state.

# In[70]:


CHA6 = algebras.CubicHecke(_sage_const_6 )
CHA6.inject_variables()
s = c0*c1*c2*c3*c4; s


# #### Caution
# 
# The basis is still indexed by the cubic braid group but build up randomly according to the sequence of your definition of elements: 

# In[71]:


sorted((s**_sage_const_2 ).support())


# In[72]:


sorted((s*c1**_sage_const_2 ).support())


# You can obtain the randomly added basis elements by:

# In[73]:


CHA6.get_order()[_sage_const_648 :]


# Some of them have also been added to the subalgebra on 5 strands:

# In[74]:


CHA5 = CHA6.cubic_hecke_subalgebra()
CHA5.get_order()[_sage_const_648 :]


# You can even obtain some irreducible matrix representations for elements of `CHA5`. But this needs `gap3` and its package `CHEVIE` to be present in your Sage: 

# In[75]:


ele5 = CHA5.an_element()
m5 = ele5.matrix(representation_type=CHA5.repr_type.SplitIrredChevie)
m5.dimensions()


# In[76]:


m5[CHA5.irred_repr.W5_013].dimensions()


# In[77]:


m5[CHA5.irred_repr.W5_010]


# ### Cashing intermediate results in the local filesystem
# 
# The new basis elements constructed as shown above for cubic Hecke algebras on more than 4 strands are saved in your local file system under `~/.sage/cubic_hecke/basis_extensions_<strands>.sobj`. If you want to reset this you can just delete or move the corresponding file to another place or name or use the `reset_filecache` method:

# In[80]:


be = CHA5.filecache_section().basis_extensions
CHA5.reset_filecache(section=be)


# The file-cache is used for other intermediate calculation results, too. Here is the list of all of them:

# In[79]:


list(CHA5.filecache_section())


# Matrix representations are cached for all basis elements. So, for at most 4 strands this cache may reach a final state. Braid images are cached after each intermediate step in the calculation which needs an application of the regular representations. The section for Markov traces is not used any more. If you call `reset_filecache` without a certain section then the complete cash will be erased.

# ## Area for your own experiments
# 
# Feel free to create more cells below to figure out the functionality. You may use all variables that have been declared above if you select the *run all*  or *run all above* item of the *Cell* drop down menue.

# In[ ]:




